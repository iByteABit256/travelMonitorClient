                Travel Monitor
               -----------------
            Pavlos Smith - sdi1800181



Compilation
------------

make


Input file generation
----------------------

./testFile.sh [viruses file] [countries file] [numOfEntries] [duplicates allowed]


example:

./testFile.sh tests/viruses.txt tests/countries.txt 10000 0



Subdirectory generation
------------------------

./create_infiles.sh inputFile input_dir numFilesPerDirectory


example:

./create_infiles.sh inputFiles/inputFile.txt entries/ 3



Execution
----------

./travelMonitor -m [numMonitors] -b [bufferSize] -s [bloomSize] -i [inputDir]


example:

./travelMonitor -m 3 -b 64 -s 100 -i entries/



    Notes:
    ------

    - Buffer size must be at least 64 bytes
    - Input directory path must end with a '/' character as shown above




Directory structure
--------------------

./data: Virus and country names used for input file generation
./inputFiles: Input files for the travel Monitor
./lib: My library of data structures that are used in the travel monitor
./src: Files that are directly relevant to the application
./logs: Log files generated by the parent and child processes upon receiving signals
./tmp: Named pipe location


Bloomfilter passing
--------------------

The child processes send one message with the name of the virus
and ceil(bloomSize/bufferSize) messages for the bloomfilters,
each message being a part of the bloomfilter as large as the
size of the buffer at most.


The parent process receives the parts and copies them into a
temporary bloom filter for each monitor. Once all monitors have
finished sending their bloomfilters (this is determined mathematically,
not with a message), the parent uses each one of the bloom filters
as an OR mask with a global bloom filter which will be used for
all the user requests.



Signal handling
----------------

sigaction(2) and sigqueue(3) are used for handling and sending
signals.

Upon receiving a SIGINT or SIGQUIT signal, the parent
waits until completion of the current command and then
sends SIGKILL to the monitors, generates a log file and
exits after releasing all of its allocated memory.

When receiving one of the forementioned signals,
the monitors generate a log file, or append to
and already existing one, and then continue
running.

Note:
    - Parent process should be killed using the kill command, not CTRL+C.
      For reasons unknown to me, the program freezes when using CTRL+C 
      instead of the kill command.




            Related info about previous project
            -----------------------------------


Assumptions
------------

In vaccineStatus, if a citizen is not in the
vaccinated skiplist, they are considered unvaccinated.

In list-nonVaccinated-Persons, only citizens that
are recorded to be non-vaccinated are shown.

The thought behind this is that, if used for a
large dataset and you use list-nonVaccinated-Persons,
you only want to know who needs to be vaccinated without
question. On the contrary, vaccineStatus seems like it would
be simpler to assume that someone is not vaccinated if they are
inexistant in the records, because it would be extremely hard
to keep track of every vaccine that hasn't been done for every
citizen.

That way, a citizen is recorded as not vaccinated when they're
aiming to be vaccinated in the future and they show up in
list-nonVaccinated-Persons without too much unneeded information.



Invalid input checking
-----------------------

When a command is parsed, I check whether there are enough
arguments and if they are valid. If the arguments weren't
enough, or at least one of them was invalid, an error
message is shown.

Invalid arguments are any types of problematic input
regarding their type. For example, the format of dates
is checked so that an argument like "01//" is invalid.

Another example is whether countries or viruses exist
in the database or not. If they aren't and a query
depends on them already existing, an error message is shown.
For instance, popStatusByAge can't give any statistics if
the virus is not already known, because we have no
information about who is vaccinated or not.



Data Structures
----------------

I use dynamic hashtables to keep countries, viruses and citizen records.
Buckets are implemented with linked lists.

Memory for strings is allocated once and only references to that memory
is stored in other structures. For example, citizen names are stored in the
struct of the person and pointers to that person are kept in the citizen hashtable.

A virus struct stores its name, its skiplists and its bloomfilter.

A country struct stores its name, its population, the populations of each age group specifically,
a counter to be used for total population percentages, and an array of counters to be used
for age-group specific percentages.

A person struct stores his/her ID, names, country pointer, and age.

A vaccine record struct stores pointers to a person and a date.
Vaccine records are passed as value to the skiplists for quick
access to vaccination dates.

Skiplists are used for vaccinated and non-vaccinated citizens for
each virus.

Bloomfilters are also used for vaccinations for quick checking
of non-vaccinated people.



Bloom Filters
--------------

Bloom filters are implemented with a char array and masks
with logical shifts for setting bits and checking them.



Skip Lists
-----------

Skip lists are implemented with a struct that contains
the max level of the skip list, the current level,
the probability of creating a new level for a new node
and a pointer to a dummy skip node.

Each skip node contains a key and a generic type item as
well as an array of skip nodes for every level in front
of it.



Known Issues
-------------

If you give incorrect input except from the expected errors
of the exercise, small memory leaks are created.
This is due to the way that lines are parsed; words are split
and memory is allocated in between, so freeing the memory after
every error would make the code much larger and unreadable than it
should be. A fix to this would be splitting all the words from the
beggining, checking for errors and then doing the necessary processing,
allowing easy and compact freeing from the beggining.
