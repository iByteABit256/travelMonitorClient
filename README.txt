                Travel Monitor Client
               -----------------------
            Pavlos Smith - sdi1800181



Compilation
------------

make


Input file generation
----------------------

./testFile.sh [viruses file] [countries file] [numOfEntries] [duplicates allowed]


example:

./testFile.sh tests/viruses.txt tests/countries.txt 10000 0



Subdirectory generation
------------------------

./create_infiles.sh inputFile input_dir numFilesPerDirectory


example:

./create_infiles.sh inputFiles/inputFile.txt entries/ 3



Execution
----------

./travelMonitorClient -m [numMonitors] -b [socketBufferSize] -c [cyclicBufferSize (max number of file paths)] -s [bloomSize] -i [inputDir] -t [numThreads]


example:

./travelMonitorClient -m 3 -b 100 -c 10 -s 100 -i entries/ -t 4



    Notes:
    ------

    - Buffer size must be at least 64 bytes
    - Input directory path must end with a '/' character as shown above




Directory structure
--------------------

./data: Virus and country names used for input file generation
./inputFiles: Input files for the travel Monitor
./lib: My library of data structures that are used in the travel monitor
./src: Files that are directly relevant to the application
./logs: Log files generated by the parent and child processes


Directory cleaning
-------------------

Use 'make clean' to remove all object files, executables and log files.


Bloomfilter passing
--------------------

The child processes send one message with the name of the virus
and ceil(bloomSize/bufferSize) messages for the bloomfilters,
each message being a part of the bloomfilter as large as the
size of the buffer at most.


The parent process receives the parts and copies them into a
temporary bloom filter for each monitor. Once all monitors have
finished sending their bloomfilters, they send a message to the parent
to indicate that they have finished, and the parent uses each one of the 
bloom filters as an OR mask with a global bloom filter which will be 
used for all the user requests.


Threads
--------

The main thread adds paths to the buffer whenever there is enough space,
while the threads are simultaneously removing paths from the buffer.
The threads exit their loop when the total number of paths has reached zero.
This total number is stored as a global variable accessible to all threads.

Mutexes are used to ensure synchronization between the threads.


Buffer functions
-----------------

All functions regarding the cyclic buffer are included from the
buffer module. The module allows me to check if a string fits in a
buffer, to check if a buffer is empty, to insert a string inside a buffer
and to remove and receive the last string in a buffer.


Command protocols
------------------

Generally, the protocol for passing commands to the monitors
is the command name, then the arguments for the command.
After writing, the parent reads the results and prints them to stdout.


Travel Stats
-------------

The command is passed to every child (country string is "NO COUNTRY" if none was given)
and the monitors each reply with their number of total, accepted and rejected requests.
The parent then sums them up and returns them.

If a request was rejected by the parent because of the bloomfilter, the rejection
is not counted.


Search Vaccination Status
--------------------------

The parent sends the request to the monitors and they reply either with
"not found" if they didn't find the requested information, or with "found"
if they did, followed by the information and a message to indicate that
the information has been all sent.

For the monitor that found the information, the parent reads from the buffer
and prints the contents to stdout until it reads "done".


Sockets
--------

gethostbyname(3) and gethostname(2) are used to get the local IP used to
establish the connection between the parent and the monitors.

The ports used are [4000, 4000+monitorNum-1], one connection for every monitor.



            Related info about previous projects
            -------------------------------------


Assumptions
------------

In vaccineStatus, if a citizen is not in the
vaccinated skiplist, they are considered unvaccinated.

In list-nonVaccinated-Persons, only citizens that
are recorded to be non-vaccinated are shown.

The thought behind this is that, if used for a
large dataset and you use list-nonVaccinated-Persons,
you only want to know who needs to be vaccinated without
question. On the contrary, vaccineStatus seems like it would
be simpler to assume that someone is not vaccinated if they are
inexistant in the records, because it would be extremely hard
to keep track of every vaccine that hasn't been done for every
citizen.

That way, a citizen is recorded as not vaccinated when they're
aiming to be vaccinated in the future and they show up in
list-nonVaccinated-Persons without too much unneeded information.



Invalid input checking
-----------------------

When a command is parsed, I check whether there are enough
arguments and if they are valid. If the arguments weren't
enough, or at least one of them was invalid, an error
message is shown.

Invalid arguments are any types of problematic input
regarding their type. For example, the format of dates
is checked so that an argument like "01//" is invalid.

Another example is whether countries or viruses exist
in the database or not. If they aren't and a query
depends on them already existing, an error message is shown.
For instance, popStatusByAge can't give any statistics if
the virus is not already known, because we have no
information about who is vaccinated or not.



Data Structures
----------------

I use dynamic hashtables to keep countries, viruses and citizen records.
Buckets are implemented with linked lists.

Memory for strings is allocated once and only references to that memory
is stored in other structures. For example, citizen names are stored in the
struct of the person and pointers to that person are kept in the citizen hashtable.

A virus struct stores its name, its skiplists and its bloomfilter.

A country struct stores its name, its population, the populations of each age group specifically,
a counter to be used for total population percentages, and an array of counters to be used
for age-group specific percentages.

A person struct stores his/her ID, names, country pointer, and age.

A vaccine record struct stores pointers to a person and a date.
Vaccine records are passed as value to the skiplists for quick
access to vaccination dates.

Skiplists are used for vaccinated and non-vaccinated citizens for
each virus.

Bloomfilters are also used for vaccinations for quick checking
of non-vaccinated people.



Bloom Filters
--------------

Bloom filters are implemented with a char array and masks
with logical shifts for setting bits and checking them.



Skip Lists
-----------

Skip lists are implemented with a struct that contains
the max level of the skip list, the current level,
the probability of creating a new level for a new node
and a pointer to a dummy skip node.

Each skip node contains a key and a generic type item as
well as an array of skip nodes for every level in front
of it.



Known Issues
-------------

If you give incorrect input except from the expected errors
of the exercise, small memory leaks are created.
This is due to the way that lines are parsed; words are split
and memory is allocated in between, so freeing the memory after
every error would make the code much larger and unreadable than it
should be. A fix to this would be splitting all the words from the
beggining, checking for errors and then doing the necessary processing,
allowing easy and compact freeing from the beggining.
